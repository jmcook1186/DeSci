pragma solidity ^0.6.6;

import '@openzeppelin/contracts/token/ERC721/ERC721.sol';

contract SciFactory is ERC721 {

  uint256 tokenID;
  uint256 tokenCount;
  address public owner;
  mapping(address => uint256[]) addressTotokenID;
  mapping(uint256 => string) public tokenIDToURI;
  mapping(uint256 => uint256) public citationCounter;

  constructor() public ERC721('dArticle', 'dART') {
    owner = msg.sender;
    tokenCount = 0;
  }



  /** 
  @dev
  Mints NFT
  must be called by the contract owner, else fail
  pushes token ID to array mapped to minter address
  calls internal set_URI function to associated NFT to metadata
  increments tokenCount by 1
  
  */
  function mint(address minter, uint256 [] memory _citedIDs) external onlyOwner returns(uint256) {

    tokenID = tokenCount;
    addressTotokenID[msg.sender].push(tokenID);
    citationCounter[tokenID]=0;
    _safeMint(minter, tokenID);
    setURI();
    tokenCount+=1;
    cite_mint(_citedIDs);
    
    return (tokenID);
  }
  

  /**
  @dev
  Function is called during minting of new NFT
  Takes a reference list of tokenIDs that are cited in the newly minted paper
  and increments the citation counter of each of those previously published NFTs
  by 1
   */
  function cite_mint(uint256[] memory _citedIDs) internal onlyOwner returns(uint256){

    for(uint i =0; i<_citedIDs.length; i++){
      uint256 _tokenID = _citedIDs[i];
      cite(_tokenID);
    }

  }


  /**
  @dev
  uses tokenID to map NFT to its metadata
  
  BaseURI is used to navigate to URI of directory containing each .json file
  tokenURI is then the base URI + the token ID and .json suffix (i.e. specific file)

  metadata number and tokenID must remain in sync for correct image/metadata to
  associate with a specific minted NFT
  
  */
  function setURI () internal {


    string memory baseURI = "https://raw.githubusercontent.com/jmcook1186/jmcook1186.github.io/main/Data/NFT_Metadata/NFT_metadata_";
    string memory suffix = ".json";
    string memory tokenURI = string(abi.encodePacked(baseURI, tokenID.toString(),suffix));
    _setTokenURI(tokenID, tokenURI);
    tokenIDToURI[tokenID] = tokenURI;

  }


  /**
  @dev
  validate URI by checking that the URI stored in the mapping
  in the contract matches that returned by the ERC721 standard
  function _tokenURI. This validates the mapping and demonstrates
  the ordering of values has stayed correct through transfers etc.

  Note that == operator does not compare content of strings in
  Solidity. As a gas-efficient workaround, compare keccak256
  hash functions generated by each string instead.
  */

  function validateURI(uint256 _tokenID) public {
      // validate URI - does ERC721 lookup match data in mapping
      
      string memory mapVal = tokenIDToURI[_tokenID];
      string memory ERC721Val = tokenURI(_tokenID);
      
      require(keccak256(bytes(mapVal)) == keccak256(bytes(ERC721Val)), "URI data error");
      
  }

  /**
  @dev
  public view function that returns URI path
   */

  function viewURI(uint256 _tokenID) public view returns(string memory){
    return tokenURI(_tokenID);
  }

  /**
  @dev
  public view function returns array of tokenIDs 
  owned by given address

  */
  function viewTokenIDsforAddress(address user) public view returns(uint256[] memory){

      uint256 N_IDs = addressTotokenID[user].length;
      uint256[] memory IDs  = addressTotokenID[user];
      
      return IDs;
  }

  
  /**
   @dev
   using simple delete operation leaves behind a zero that is easily 
   misinterpreted as tokenID 0. Therefore, move the doomed element
   to the end of the array then shorten the array to erase completely.
   Do this by whipping up small internal function "delete_element", 
   then call it from inside safeTranferFrom().
  */
  function delete_element(uint idx, uint256[] storage _array) internal returns(uint256[] storage){
    
    if(idx >= _array.length){return _array;}

    for (uint i = idx; i<_array.length-1; i++){
      _array[i] = _array[i+1];
    }

    //delete _array[_array.length-1];
    _array.pop();

    return _array;

  }


  /**
  @dev
  borrow function increments citation counter when this NFT is "checked out"
  the pdf is actually freely available by downloading from the IPFS link
  which is provided on the NFT's OpenSea page. However, when other articles
  are minted as PDFs they "borrow" this one if they cite it.
  
  In most cases this function is called by cite_mint, but it is also useful to
  have an alternative so that citations from pre-SciFactory days can be included
  and to provides devs with mechanism for correcting user errors in initial mint
  
   */
  function cite (uint256 _tokenID) public {

    require(_isApprovedOrOwner(msg.sender,_tokenID));
    citationCounter[_tokenID]+=1;

  }



  /**
  @dev
  burn citations exists to adjust the citation count in
  case a citing paper is retracted or some other error occurs
   */
  function burnCitations (uint256 _tokenID) public {
    require(_isApprovedOrOwner(msg.sender,_tokenID));
    citationCounter[_tokenID]-=1;

  }

  /**
  @dev
  public view function returns number of tmes paper has been cited by
  extracting uint256 from mapping to tokenID.
   */
  function viewCitations(uint256 _tokenID) public view returns(uint256){
    return citationCounter[_tokenID]; 
  }

  /**
  @dev
  overrides safeTransferFrom in ERC721 standard to maintain synchronicity with
  address=>tokenID mapping in addressTotokenID.
  
  */
  function safeTransferFrom(address from, address to, uint256 _tokenID, bytes memory _data) public override{
    require(_isApprovedOrOwner(_msgSender(), _tokenID), "ERC721: transfer caller is not owner nor approved");
    _safeTransfer(from, to, _tokenID, _data);


    addressTotokenID[from] = delete_element(_tokenID, addressTotokenID[from]);

    addressTotokenID[to].push(_tokenID);
    
    }


  /**
  @dev
  overrides ERC721 transferFrom with call to safeTransferFrom()
  */
  function transferFrom(address from, address to, uint256 _tokenID) public override {
    
    safeTransferFrom(from, to, _tokenID);

    }


  modifier onlyOwner() {
    require(owner == msg.sender);
    _;
  }

}